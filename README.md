## ValueType

 В библиотеке **ValueTypeLibrary** представлена эффективная _expressions-tree_ реализация
 абстрактного класса **ValueType**. Этот класс может быть полезен в ситуациях, когда в проекте
 имеется некоторое количество классов, поддерживающих семантику значений, то есть таких,
 экземпляры которых мы считаем равными в том случае, если равны их соответствующие публичные
 свойства.<br />
 В случае, если таких value-type-классов в проекте много, переопределение методов **Equals** и **GetHashCode**
 для каждого из них может превратиться в большое количество однотипного инфраструктурного кода.
 Этот код в каждом из классов будет требовать поддержки и соответствующего расширения в случае, если
 мы решим добавить в какой-нибудь из классов новое свойство. Для больших проектов с большим количеством
 классов и постоянно расширяющейся кодовой базой это может стать настоящей проблемой и потенциальным
 источником трудноотслеживаемых ошибок.<br />
 Наследование таких value-классов от **ValueType** может решить описанные проблемы "автоматическим"
 переопределением методов **Equals** и **GetHashCode** с помощью построения специфичных каждому конкретному
 классу функций. Такой подход не вызовет проблем с производительностью, данное решение
 будет почти таким же быстрым, как и нативное переопределение методов **Equals** и **GetHashCode**
 "руками".<br />
 Альтернативная наивная _Reflection_-реализация выглядит просто и понятно
 (см. **ValueTypeLibrary_Reflection**), однако многократно проигрывает в производительности
 _Expressions_-подходу, поэтому может не подойти для некоторых проектов.
 
**P.S.** Разумеется, в по-настоящему универсальном решении стоило бы предусмотреть так же
сравнение по публичным полям и возможность не включать некоторые публичные поля и свойства
в сравнение с помощью соответствующих аттрибутов, но в контексте моей задачи этого
пока что не требуется, поэтому прислушаемся к YAGNI :)